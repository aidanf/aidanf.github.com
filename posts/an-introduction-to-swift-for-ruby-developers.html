<!doctype html>
<html><!-- InstanceBegin template="/Templates/page-full-width.dwt" codeOutsideHTMLIsLocked="false" -->

<head>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" >
    <meta name="description" content="Aidan Finn's Website">
    <meta name="keywords" content="swift, clojure, ios, screencasts, book, python, ruby, machine learning, sligo">
    <meta name="author" content="Aidan Finn">

    <!-- InstanceBeginEditable name="doctitle" -->
    <title>
        An introduction to Swift for Ruby Developers - /aidanf/
    </title>
    <!-- InstanceEndEditable -->

    <!-- FAV and TOUCH ICONS -->
    <link rel="shortcut icon" href="/favicon.ico">

    <!-- FONTS -->
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=UnifrakturMaguntia' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Coustard' rel='stylesheet' type='text/css'>

    <!--[if lte IE 9]>
        <script src="/js/html5shiv.js"></script>
        <script src="/js/selectivizr-min.js"></script>
    <![endif]-->

    <!-- STYLES -->
    <link rel="stylesheet" type="text/css" media="print" href="/css/print.css">
    <link rel="stylesheet" type="text/css" href="/css/grid.css">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/font-awesome.css">
    <link rel="stylesheet" type="text/css" href="/css/uniform.default.css">
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="stylesheet" type="text/css" href="/css/flexslider.css">

    <!-- SCRIPTS -->
    <!-- Grab Google CDN's jQuery, with a protocol relative URL; fall back to local if offline -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="/js/jquery-1.8.3.min.js"><\/script>')</script>


    <!-- InstanceBeginEditable name="head" -->
	<!-- InstanceEndEditable -->

    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-539512-1', 'auto');
        ga('send', 'pageview');
    </script>

        
</head>

<body>

    <!-- #PAGE -->
    <div id="page" class="hfeed site">

      

<!-- .site-header -->
<header class="site-header wrapper" role="banner">

    <!-- .row -->
    <div class="row">

        <!-- .site-title -->
        <hgroup>
            <h1 class="site-title"><a href="/" title="/aidanf/" rel="home">/aidanf/</a></h1>
            <h2 class="site-description">musings of a curious coder</h2>
        </hgroup>
        <!-- .site-title -->

        <!-- #site-navigation -->
        <nav id="site-navigation" class="main-navigation" role="navigation">
            <ul>
                <li ><a href="/">Blog</a></li>
                <li ><a href="/learn-swift">Learn Swift</a></li>
                <li ><a href="/about">About</a></li>
            </ul>
        </nav>
        <!-- #site-navigation -->

    </div>
    <!-- .row -->
</header>
<!-- .site-header -->

      <!-- #main -->
      <section id="main" class="middle wrapper">
        <div class="row row-fluid">





                <!-- #primary -->
                <div id="primary" class="site-content">

                    <!-- #content -->
                    <div id="content" role="main">
                      <!-- InstanceBeginEditable name="Middle-Content" -->

<!-- .blog-single -->
<div class="blog-single readable-content">


    <!-- .hentry -->
    <article class="post type-post format-standard hentry">


        <!-- .entry-header -->
        <header class="entry-header">
            <h1 class="entry-title">An introduction to Swift for Ruby Developers</h1>
        </header>
        <!-- .entry-header -->

        <!-- .entry-meta -->
        <div class="entry-meta">
            posted
            on <a href="#" title="11:15 pm" rel="bookmark">
            <time class="entry-date" datetime="2015-05-27T00:00:00+01:00">May 27, 2015
            </time>
        </a>

            <!-- .share-links -->
            <div class="share-links">
                <a>SHARE</a>

                <!-- .share-wrap -->
                <div class="share-wrap">

                    <!-- .facebook-wrap -->
                    <div class="facebook-wrap">

                        <div id="fb-root"></div>
                        <script>(function (d, s, id) {
                            var js, fjs = d.getElementsByTagName(s)[0];
                            if (d.getElementById(id)) return;
                            js = d.createElement(s);
                            js.id = id;
                            js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
                            fjs.parentNode.insertBefore(js, fjs);
                        }(document, 'script', 'facebook-jssdk'));</script>
                        <div class="fb-like" data-send="false" data-layout="button_count" data-width="400"
                             data-show-faces="false" data-colorscheme="light" data-action="like"></div>

                    </div>
                    <!-- .facebook-wrap -->

                    <!-- .twitter-wrap -->
                    <div class="twitter-wrap">
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function (d, s, id) {
                            var js, fjs = d.getElementsByTagName(s)[0];
                            if (!d.getElementById(id)) {
                                js = d.createElement(s);
                                js.id = id;
                                js.src = "//platform.twitter.com/widgets.js";
                                fjs.parentNode.insertBefore(js, fjs);
                            }
                        }(document, "script", "twitter-wjs");</script>
                    </div>
                    <!-- .twitter-wrap -->

                    <!-- .google-wrap -->
                    <div class="google-wrap">
                        <!-- Place this tag where you want the +1 button to render. -->
                        <div class="g-plusone" data-size="medium"></div>

                        <!-- Place this tag after the last +1 button tag. -->
                        <script type="text/javascript">
                            (function () {
                                var po = document.createElement('script');
                                po.type = 'text/javascript';
                                po.async = true;
                                po.src = 'https://apis.google.com/js/plusone.js';
                                var s = document.getElementsByTagName('script')[0];
                                s.parentNode.insertBefore(po, s);
                            })();
                        </script>
                    </div>
                    <!-- .google-wrap -->

                    <!-- .pinterest-wrap -->
                    <div class="pinterest-wrap">
                        <a href="http://pinterest.com/pin/create/button/?url=http%3A%2F%2Fthemes.pixelwars.org%2Fread%2Fblog-single.html&media=http%3A%2F%2Fthemes.pixelwars.org%2Fread%2Fimages%2Fblog%2Fblog-01.jpg&description=Adaptive%20Vs.%20Responsive%20Layouts%20And%20Optimal%20Form%20Field%20Labels"
                           class="pin-it-button" count-layout="horizontal"><img
                                src="//assets.pinterest.com/images/PinExt.png" alt="Pin It" title="Pin It"/></a>
                        <script type="text/javascript" src="//assets.pinterest.com/js/pinit.js"></script>
                    </div>
                    <!-- .pinterest-wrap -->

                </div>
                <!-- .share-wrap -->


            </div>
            <!-- .share-links -->


        </div>
        <!-- .entry-meta -->


        <!-- .featured-image -->
        
        <!-- .featured-image -->


        <!-- .entry-content -->
        <div class="entry-content">
            <p>If you want to learn to develop apps for iOS and OS X there are a number of bottlenecks that you need to overcome.</p>

<ol>
  <li>Learn how to program.</li>
  <li>Learn a language for developing on the Apple ecosystem, generally Swift or Objective-C.</li>
  <li>Learn the development tools:  Xcode etc.</li>
  <li>Learn the Cocoa APIs.</li>
</ol>

<p>If you already know how to program in Ruby, then you’ve already overcome the first bottleneck.</p>

<p>But if Ruby is your main programming language, then bottleneck number 2 has up to now been a significant hurdle.</p>

<p>Thus in recent years there have been several tools that allow you to develop iOS applications without having to learn Objective-C (e.g. <a href="http://www.appcelerator.com/product/">Titanium</a>, <a href="http://phonegap.com/">PhoneGap</a>, <a href="http://www.rubymotion.com/">rubymotion</a>, <a href="http://xamarin.com/platform">Xamarin</a>)</p>

<p>For Rubyists who are accustomed to the benefits and comforts that come with programming in Ruby, Objective-C is not a particularly pleasant language to program in and the learning-curve can be quite steep. But that has changed significantly with the recent release of Swift.</p>

<p>The jump from Ruby to Swift is much smaller than the jump from ruby to Objective-C. If you like Ruby, you’ll probably find that a lot to like about Swift.</p>

<p>In this article I’ll outline a number of interesting features from Swift and compare them with the equivalent features in Ruby.</p>

<h1 id="some-basics">Some basics</h1>

<h3 id="constants-and-variables">Constants and variables</h3>

<p>Everything in mungable in Ruby. Even constants are constant only by convention - you’ll get a warning if you try to change them but you can still go ahead and change them.</p>

<p>Swift is much stricter (in general, this is a theme. Swift is generally more strict about things than Ruby.)</p>

<p>In Ruby constants are conventionally defined using capital letters. If we really want to change a constant, we can. Ruby will generate a warning if we do this, but not an error.</p>

<script src="https://gist.github.com/aidanf/005b9ede917718d08bea.js"></script>

<p>We can create a new variable at any time simply by assigning it. And we can change the type of that variable at any time by assigning a new value. In this example, <code class="highlighter-rouge">x</code> is consecutively an <code class="highlighter-rouge">Integer</code>, a custom <code class="highlighter-rouge">Object</code> and a <code class="highlighter-rouge">String</code> all in the space of a few lines. This dynamism is a core part of Ruby’s philosophy - in Ruby anything can change at any time. This is what gives rise to a lot of Ruby’s meta-programming power. But it can also lead to some frustrating bugs and bad habits when comes to programming in the large.</p>

<script src="https://gist.github.com/aidanf/fdf3e290cf4f88c637ed.js"></script>

<p>Swift takes a much stricter approach to constants and variables. In Swift all values are strictly typed. This has two implications that are a significant change to what you are accustomed to with Ruby.</p>

<ol>
  <li>You must declare the type of all of your variables and constants, or else assign them an initial value which Swift will use to infer their type.</li>
  <li>You can’t change the type of a variable once you’ve declared it. It’s type is fixed and cannot be changed. For constants, their value is also fixed and can’t be changed once they’ve been initialised.</li>
</ol>

<script src="https://gist.github.com/aidanf/ec59e4765e1106d0804d.js"></script>

<p>In Swift you declare a variable using the <code class="highlighter-rouge">var</code> keyword and constants using the <code class="highlighter-rouge">let</code> keyword.</p>

<p>Constants are immutable. Once you’ve declared them, they cannot be changed again. Attempting to modify a constant in any way will result in an error.</p>

<h3 id="arrays">Arrays</h3>

<p>In Ruby, you can declare an array and add multiple different types to it.</p>

<script src="https://gist.github.com/aidanf/bb1d15a81da6fb538073.js"></script>

<p>Arrays is Swift are similar to arrays in Ruby with one notable difference. In Swift, arrays are typed. You declare the type of the array (or Swift infers it) and you can only add items that are of the same type to the array. You can’t generally store multiple different types in an array. There are ways to include objects of different types in an array (using protocols or inheritance), but for the most part you’ll stick to only having one type of thing in your array.</p>

<script src="https://gist.github.com/aidanf/e02bf7c721a32b982e4a.js"></script>

<h3 id="dictionaries">Dictionaries</h3>

<p>Similar to Arrays, Dictionaries in Swift are typed. You need to specify the type of both the keys and the values when you declare the dictionary. Once initialised, your dictionary can only contain key-value pairs that match that type signature.</p>

<p>Also, similar to arrays, you can declare the type signature for the dictionary explicitly or Swift can infer it from the initial values.</p>

<p>Apart from being typed, dictionaries in Swift are similar to dictionaries in Ruby. Here’s an example of declaring a dictionary and accessing it’s elements.</p>

<script src="https://gist.github.com/aidanf/ce52d0288ef693ff10a1.js"></script>

<h3 id="tuples">Tuples</h3>

<p>A tuple is an ordered list of elements. Tuples provide a way to group multiple values together. Many languages provide tuples as a native data type. Commonly there are two ways of accessing the data in a tuple: by position or by name. Swift provides tuples as a native data type along with the ability to access the tuples data both by name and by position.</p>

<p>Ruby doesn’t formally have tuples, although you can approximate their behaviour using a couple of techniques.</p>

<p>For example, you can use a convention where you treat a short list as a tuple. This is a common pattern in Ruby, where you return a short list of 2 or 3 elements from a method and these are decomposed into individual variables using the assignment operator.</p>

<script src="https://gist.github.com/aidanf/ddcb0819ee6e12c4d5fb.js"></script>

<p>Or, if you want to be able to use dot notation to access elements in a tuple, you could use an object or struct.</p>

<script src="https://gist.github.com/aidanf/665f03dbb93a4fa00238.js"></script>

<p>So while Ruby doesn’t provide tuples as a native type, we can approximate much of the behaviour of tuples using Ruby arrays or structs.</p>

<p>In Swift tuples are one of the native types. A tuple can consist of multiple different types. Tuples are ordered and elements of tuples can also be named. So we can access elements of a tuple both by position and name, and we can deconstruct data into a tuple using the assignment operator. Lets go through some examples of how we use tuples in swift.</p>

<p>Tuples are defined using <code class="highlighter-rouge">()</code>. We can decompose a tuple into it’s parts using the assignment operator.</p>

<script src="https://gist.github.com/aidanf/98e179ce60e35804a9ba.js"></script>

<p>Here we create a tuple consisting of 2 floats. We can assign the contents to <code class="highlighter-rouge">lat</code> and <code class="highlighter-rouge">lon</code> using assignment. If we don’t care about all of the contents of the tuple we can use <code class="highlighter-rouge">_</code> to indicate fields that we don’t care about. In line 5 we just extract the value of the first element of the tuple into a constant - the <code class="highlighter-rouge">_</code> indicates that we don’t care about the second.</p>

<script src="https://gist.github.com/aidanf/bcaede19230a9ea2a644.js"></script>

<p>We can also access the elements of a tuple by position or by name. Here we define a tuple with named fields. We do this by providing the names as keys when we create the tuple (line 1). In this example we’ve named the first field <code class="highlighter-rouge">code</code>, and the second field <code class="highlighter-rouge">message</code>.</p>

<h3 id="naming-things">Naming things</h3>

<p>One immediately noticeable difference is code style, especially with regard to how we name things. Ruby generally uses snake-case for methods and variables and camel-case for classes and capitalised names for constants.</p>

<p>Swift programs use camel case for all these. Essentially:</p>

<ul>
  <li>CamelCase for everything</li>
  <li>class names and top-level constants should be capitalized</li>
  <li>method names, function names and variable names should start with a lower-case letter</li>
</ul>

<h3 id="truthiness">Truthiness</h3>

<p>In Ruby <code class="highlighter-rouge">nil</code> and <code class="highlighter-rouge">false</code> are falsey and everything else is truthy. Thus you can use the presence of something as a logical condition. In Ruby we can use any type or expression in a boolean operator or an if condition.</p>

<script src="https://gist.github.com/aidanf/6cf01dd24bd5ebaaad69.js"></script>

<p>Swift is much stricter in it’s treatment of boolean values. Booleans in Swift are of type <code class="highlighter-rouge">Bool</code> and can be either <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>. Anything in Swift that takes a boolean, must use a real boolean type. Any operator or function that expects a boolean must be given a boolean or the type system will complain.</p>

<script src="https://gist.github.com/aidanf/a1e393e81b95345569ea.js"></script>

<p>So we can’t do things like what’s shown below in Swift. In both cases we’ll get an error along the lines of “Type ‘String’ does not conform to protocol ‘BooleanType’”.</p>

<script src="https://gist.github.com/aidanf/bf5bc415cf0aa309c779.js"></script>

<p>Booleans in Swift are declared using the keyword <code class="highlighter-rouge">Bool</code> or by initializing them with <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>.</p>

<h1 id="running-code">Running Code</h1>

<p>One of the major differences between writing Ruby code and writing Swift code is the tooling involved.</p>

<p>Although some Rubyists use an IDE such as RubyMine, most generally use a text editor such as Sublime, Emacs or Vi in combination with the command line and interactive console.</p>

<p>For Swift development you’ll generally need to get to know Apple’s development tools. While it’s possible to setup your development workflow using other tools, I wouldn’t recommend it, especially if you are new to mac development.</p>

<p>As a Ruby developer you’ll probably use interactive console a lot when doing development. The repl (e.g. irb, pry) provides a quick way of testing out code and inspecting how a piece of code behaves.</p>

<p>Previously with Objective-C you’d have to compile and run a program to test out new code. The compile-run cycle was a pain for developers used to developing with an interactive repl.</p>

<p>Luckily, the tools for interactive code development have improved significantly with the release of Swift. Xcode now has an interactive repl for running Swift code. It also has a new feature called <a href="http://books.aidanf.net/learn-swift/running_code#sec-playgrounds">playgrounds</a> that allow you to try out and run code interactively.</p>

<h1 id="static-typing-and-type-inference">Static typing and type inference</h1>

<p>Swift is statically, strongly typed and uses type inference to determine the initial type of all your variables and constants.</p>

<p>We’ve already touched on swift’s type system a couple of times - it’s one of the most immediately noticeable differences between ruby and swift. It such an important part of the language that it’s time to dive in deeper before we go any further.</p>

<h2 id="typing-in-ruby">Typing in Ruby</h2>

<p>First lets review typing in Ruby. Ruby is strongly, dynamically typed.</p>

<p>Let’s break down those two dimensions. Being strongly typed means that an operation that expects a certain type is checked for that type before the operation is performed. With a weakly typed language, no such checking is done. Lets take a short detour to look at a weakly typed example to help us better understand strong typing.</p>

<p>JavaScript is a weakly typed language. If we fire up our JavaScript console and try the following:</p>

<script src="https://gist.github.com/aidanf/6d79e07d9336dad3a987.js"></script>

<p>we can see that JavaScript will happily take a string and an integer and use them as arguments to the <code class="highlighter-rouge">+</code> function. In this example it coerces the integer to a string and appends it to the string.</p>

<p>If we try the same in ruby we get an error since ruby is strongly typed.</p>

<script src="https://gist.github.com/aidanf/22f494712d011fa030b3.js"></script>

<p>The <code class="highlighter-rouge">+</code> method in ruby expects two arguments to be of the same type. The <code class="highlighter-rouge">+</code> method called on a string expects to be passed a string, and the <code class="highlighter-rouge">+</code> method passed to a number expects to be passed a number. So in Ruby we need to be more specific about the behaviour we want here and do the correct type coercion ourselves.</p>

<script src="https://gist.github.com/aidanf/fac3a699f3e19e03be39.js"></script>

<p>Ruby is also dynamically typed. Dynamic typing means that the type of something can change through the course of a program, and the type is determined at the time at which it is used.</p>

<script src="https://gist.github.com/aidanf/548c005109e6e22bf2d8.js"></script>

<p>In this example, x starts out as a string, and we can pass it to <code class="highlighter-rouge">+</code> to concatenate it to another string. Then we can change it’s type to an Float, just by assigning a Float value to it. Now when we call <code class="highlighter-rouge">+</code> with x as an argument we get different behaviour because it’s now a number.</p>

<p>In fact Ruby doesn’t really have a strong notion of types at all. Everything is an object and the “type” of an object is determined by it’s behaviour rather than the class of the object. This approach is often referred to as “duck typing”. If it looks like a duck and it quacks like a duck, then for all we care it’s a duck. <em>The type of something doesn’t matter - what matters is how it behaves</em>. So you can usually pass any object as an argument to a method if it implements the behaviour that the method expects. In the following example we see an array of pets, where each pet is a different class, and each pet makes some kind of noise. We iterate through each object calling it’s <code class="highlighter-rouge">make_noise</code> method.</p>

<script src="https://gist.github.com/aidanf/5826caeb61b6c3f179e0.js"></script>

<p>The output from running this program is</p>

<p>``` ruby code/duck_typing.rb
Quack!</p>

<p>Woof!
```</p>

<p>In this example, Ruby doesn’t care about the type of each object, (i.e. which class it is), only that it responds to the <code class="highlighter-rouge">make_noise</code> method. If it looks like something that can <code class="highlighter-rouge">make_noise</code>, then that’s good enough. Ruby doesn’t do any type-checking other than checking that the object responds to the method that we’re trying to call on it.</p>

<p>That’s a quick tour of typing in Ruby. If you’ve been mainly programming in Ruby for a while, then you’re probably not used to thinking about the types of your objects in any great detail, especially during the design phase of your program, since it’s easy to change them as you go along. Swift’s type system will be one of the most immediately noticeable and profound differences in philosophy between the two languages. Lets look at Swift’s type system.</p>

<h2 id="typing-and-type-inference-in-swift">Typing and type inference in Swift</h2>

<p>Swift is strongly, statically typed.</p>

<h3 id="statically-typed">Statically typed</h3>
<p>Being statically typed means that all your variables, constants, functions must have their types declared in advance. Then the compiler uses these type declarations to check that there are no type errors when it compiles the program. If there is a type error, your program won’t compile.</p>

<p>Unlike Ruby, all your variables must have a declared type, and <em>once declared (or inferred) that type cannot change</em>. Trying to change the type of something will result in an error.</p>

<p>In this example, we declare an integer variable (Swift infers that it’s an integer from our initial assignment). Trying to assign a string value to our variable will cause swifts to raise a type error.</p>

<script src="https://gist.github.com/aidanf/77a65d7026db0178ba69.js"></script>

<h3 id="type-inference">Type inference</h3>

<p>As we’ve mentioned already Swift uses type inference to infer what types your various variables have. Alternatively you can  explicitly declare the type of your variables but in practice you often don’t need to. Swift will infer the type of a var if you assign it an initial value. So when you declare a variable, you need to either  give it an initial type, or explicitly declare it’s type. Here’s an example of how we can declare a type explicitly.</p>

<script src="https://gist.github.com/aidanf/5bb16f21595a3c6f6d0c.js"></script>

<p>In line 1 we declare a string variable and give it in initial value. Because we gave it an initial value, we don’t need to explicitly declare the type of the variable - Swift infers that this is a string.</p>

<p>In line 2 we see how to initialize a variable without giving it an initial value. In this case, because we didn’t give the variable an initial value, swift can’t infer it’s type, so we need to explicitly define it’s type as a <code class="highlighter-rouge">String</code>. At line 3 then we can assign a string value to that variable. If we tried to assign a value of a different type we would get an error.</p>

<h3 id="strongly-typed">Strongly typed</h3>

<p>Like Ruby, Swift is strongly typed. Whenever you use a variable or pass something as a function argument, Swift checks that it is of the correct type. You can’t pass a String to a function that expects an Integer etc. Unlike ruby, swift does this check at compile time (since it’s statically typed) whereas ruby does this check at runtime (and then only at the point where the method being checked is called).</p>

<p>Here’s an example where we declare a function. A function has a type signature and anytime you call the function, your function call must correspond to that type signature.</p>

<script src="https://gist.github.com/aidanf/1a0504347c1dc793ae7e.js"></script>

<p>The type signature for this function indicates that it takes 2 arguments, both of which are integers and it returns an integer ( <code class="highlighter-rouge">-&gt; Int</code> indicates the return type of the function)</p>

<p>If we try to call this function with 2 integers as arguments (line 5) it returns an integer. But if we try to call it with arguments that aren’t 2 integers we’ll get an error (line 6).</p>

<h2 id="type-safety">Type Safety</h2>

<p>Ruby is not type-safe. In Ruby you can pass an object of any type to a function - Ruby will happily use that object if it implements the expected methods (duck-typing). If it doesn’t, then you’ll end up with a runtime error.</p>

<p>Swift is a type-safe language. All variables have a declared type. All functions/methods have a type signature which declares the types of it’s arguments and the type of what it returns. The Swift compiler checks at compile time that all your types match up and your program won’t compile if they don’t.</p>

<p>Swift uses the type signature of your functions and methods to make sure they are being called correctly (i.e. with the correct types). It also uses type signature for function dispatch. So you can define multiple versions of a function with different types signatures, and the one that gets called is the one where the arguments type signatures match. Here’s an example where we defining two functions with the same name, but different type signatures. If we call call the function with floats as arguments, the first one gets called, and if we call it with integer arguments, the second one gets called.</p>

<script src="https://gist.github.com/aidanf/81bff8ba5b3772990463.js"></script>

<h2 id="the-benefits-of-static-typing">The benefits of static typing</h2>

<p>One of the things I liked when I started programming in Python and Ruby was that I didn’t need to declare the type of everything. Just being able to assign and use a variable when I needed it felt freeing, and the lack of a compilation step really seemed to speed up development. Later I learned that you don’t really gain much in the long term. That initial boost in development speed gets eaten up later in the project, when you’re debugging runtime errors, writing extensive test suites etc.</p>

<p>Having to declare your types and satisfy the compiler’s type system is not as onerous as it may appear. Since I started using languages with good, strong type systems, it’s become something that I miss when I’m programming in dynamic languages such as Ruby. A few points on the benefits/costs of static typing:</p>

<ul>
  <li>In Ruby, you still need to be aware of the types of the objects (along with how they behave) that your are passing around your program. Often passing the wrong type of object to a method that expects something else will result in an error (which you won’t notice until your program is running). In fact by not explicitly declaring and designing your types, you increase the cognitive workload associated with keeping track of all the objects you’re passing around your program.</li>
  <li>You don’t actually save that much. In the grander scheme of things, declaring the types of things in your program is a tiny portion of the overall amount of work involved in building a working program. And whatever time and typing you end up saving by not having to declare your types, you’ll end up using it to write unit tests and writing documentation for your function arguments anyway.</li>
  <li>With static typing you end up with less meta-programming power. For some problems this means that you’ll end up with a solution that is more explicit and less “magicy”. Ruby has powerful meta-programming facilities which can facilitate elegant solutions for come kinds of problems (e.g implemening a DSL). For larger systems and long-term maintenance and readability the absense of magic can actually a benefit.</li>
  <li>You may have been put off static-typing from experiences in other languages such as java or c++. They’re type systems suck, and get in your way as much as they help you.  However the type system in Swift is better. If you embrace it you’ll find it extremely useful in writing more correct programs.</li>
  <li>You can often deduce what a function does from it’s type signature. This is very useful for making code more readable and understandable</li>
  <li>Refactoring becomes easier, and you have a bunch of compiler errors to tell you where you broke things.</li>
  <li>In Swift you don’t give up on the advantages of being able to develop without a compile step. The fact that you have a repl and playgrounds give you many of the benefits that come with dynamic languages by removing the historically slow and annoying step of having to constantly compile your code to see if works.</li>
</ul>

<h1 id="duck-typing-generics-and-protocols">Duck Typing, Generics and Protocols</h1>

<p>We already discussed how Ruby implements duck typing, and how you can pass any type of objects to a function so long as they implement the expected behaviour.</p>

<p>There are 2 concepts in Swift that support similar behaviour.</p>

<p>Generics allow you to define code that works with multiple types. Protocols allow you to declare that something must implement particular functionality.</p>

<p>Let’s consider a simple function that does nothing except return it’s argument.</p>

<p>In Ruby we could write:</p>

<script src="https://gist.github.com/aidanf/d38e2957205e3206e2b5.js"></script>

<p>Ruby will happily return the argument here without worrying about it’s type.</p>

<p>Now in Swift, we have to define  the type signature of this function when we define it. And based on what we know so far, we would need to define a function that takes and integer as an argument, and another function that takes a string as an argument, and another function for whatever other types we want to support.</p>

<p>That’s where generics come in. We can define this as a generic function, which indicates it can work with multiple types. Here’s how we define our generic doNothing function in swift.</p>

<script src="https://gist.github.com/aidanf/b6239b3fa393b516fc46.js"></script>

<p>Putting <code class="highlighter-rouge">&lt;T&gt;</code> here after the function name indicates that we are defining a generic function, with <code class="highlighter-rouge">T</code> as the placeholder for the type of whatever get’s passed as an argument. Specifically, the type signature for this function says that it’s a generic function that takes a single argument of type <code class="highlighter-rouge">T</code> and returns something of type <code class="highlighter-rouge">T</code>.</p>

<p>We previously had an example of duck typing in ruby.</p>

<script src="https://gist.github.com/aidanf/bca6272743902f6b4a48.js"></script>

<p>But in Swift an array must be typed - we have to specify the type of an array and then we can only put objects of that type into it.</p>

<p>Protocols allow us to specify that something must implement specific behaviour. But Protocols are also first class types in Swift. So we can use a protocol as the type for an array, and then we can put any object that adopts that protocol into that array.</p>

<script src="https://gist.github.com/aidanf/71511b704c6fbdea9f3a.js"></script>

<p>Here we declare an array for holding our animals and give it a type of <code class="highlighter-rouge">Noisy</code>. That array can store any object that implements the <code class="highlighter-rouge">Noisy</code> protocol. This lets us implement duck typing in Swift, while still getting the benefits of Swift’s type system.</p>

<h1 id="in-summary">In Summary</h1>

<p>Swift is a very nice language and for anyone fluent in Ruby is should be relatively easy to learn. Like Ruby, functions and blocks are first-class objects and many of the patterns that are familiar to Ruby programmers translate directly to Swift. <a href="http://books.aidanf.net/learn-swift/classes">Classes in Swift</a> are more or less the same as in Ruby. <a href="http://books.aidanf.net/learn-swift/optionals">Optionals in Swift</a> are an interesting analog to how we often use <code class="highlighter-rouge">nil</code> in Ruby.</p>

<p>The major difference in Swift that is noticeable when coming from Ruby is the type system. Once you get used to that, the rest is plain sailing. Swift is easy enough to learn that you don’t lose anything by choosing to develop in Swift over choosing to use something like RubyMotion. The learning curve in learning Swift will be relatively gentle compared to the learning curve of the various Cocoa APIs.</p>

        </div>
        <!-- .entry-content -->


    </article>
    <!-- .hentry -->

    <!-- .nav-single -->
    <nav class="nav-single row-fluid">
        
        <div class="nav-previous span6">
            <h4>PREVIOUS POST</h4>
            <a href="/posts/a-list-of-python-software-for-deep-learning" rel="prev"><span class="meta-nav">←</span> A list of python software for deep learning</a>
        </div>
        

        
        <div class="nav-next span6">
            <h4>NEXT POST</h4>
            <a href="/posts/how-vowpal-wabbit-featurizes-text" rel="next">How does vowpal wabbit featurize text? <span class="meta-nav">→</span></a>
        </div>
        

    </nav>
    <!-- .nav-single -->

</div>
<!-- .blog-single -->


<!-- InstanceEndEditable -->
                    </div>
                    <!-- #content -->

                </div>
                <!-- #primary -->





         </div>
      </section>
      <!-- #main -->





          <!-- .site-footer -->
      <footer class="site-footer wrapper" role="contentinfo">
        <!-- .row -->
        <div class="row">


          <!-- #supplementary -->
          <div id="supplementary" class="row-fluid">


            <!-- .widget-area -->
            <!--<div class="widget-area span3" role="complementary">

              <aside class="widget widget_text">
                <h3 class="widget-title">About Read</h3>
                <div class="textwidget">Read is a minimalistic wordpress theme focused on readability. This is a just text widget with some dummy content. This is a just text widget with some dummy content. This is a just text widget with some dummy content.</div>
              </aside>

            </div>-->
            <!-- .widget-area -->


            <!-- .widget-area -->
            <!--<div class="widget-area span3" role="complementary">

              <aside class="widget widget_recent_entries">
                  <h3 class="widget-title">Recent Posts</h3>
                  <ul>
                    <li><a href="#" title="Thinking About Responsive Design">Thinking About Responsive Design</a></li>
                    <li><a href="#" title="Adaptive Vs. Responsive Layouts And Optimal Form Field Labels">Adaptive Vs. Responsive Layouts And Optimal Form Field Labels</a></li>
                    <li><a href="#" title="Hello world!">Hello world!</a></li>
                  </ul>
                </aside>

            </div>-->
            <!-- .widget-area -->

            <!-- .widget-area -->
            <!--<div class="widget-area span3" role="complementary">

              <aside class="widget widget-instagram">
                  <h3 class="widget-title">Photos on Instagram</h3>
                  <div class="instagram"></div>
                  <script src="../js/instagram.js"></script>
                </aside>

            </div>-->
            <!-- .widget-area -->

            <!-- .widget-area -->
            <!--<div class="widget-area span3" role="complementary">

              <aside class="widget widget_categories">
                  <h3 class="widget-title">Categories</h3>
                  <ul>
                    <li><a href="#" title="View all posts filed under Uncategorized">Web Design</a></li>
                    <li><a href="#" title="View all posts filed under Uncategorized">Javascript</a></li>
                    <li><a href="#" title="View all posts filed under Uncategorized">Typography</a></li>
                    <li><a href="#" title="View all posts filed under Uncategorized">Freebies</a></li>
                  </ul>
                </aside>

            </div>-->
            <!-- .widget-area -->


          </div>
          <!-- #supplementary -->


          <!-- .site-info -->
          <div class="site-info">(c) Aidan Finn</div>
          <!-- .site-info -->

        </div>
        <!-- .row -->
      </footer>
      <!-- .site-footer -->

    </div>
    <!-- #PAGE -->




    <!-- SCRIPTS -->
    <script src="/js/detectmobilebrowser.js"></script>
    <script src="/js/modernizr.js"></script>
    <script src="/js/jquery.imagesloaded.min.js"></script>
    <script src="/js/jquery.fitvids.js"></script>
    <script src="/js/jquery.uniform.min.js"></script>

    <!-- InstanceBeginEditable name="body-end" -->
    <script src="/js/jquery.validate.min.js"></script>
	<!-- InstanceEndEditable -->

    <script src="/js/main.js"></script>

</body>
<!-- InstanceEnd --></html>
